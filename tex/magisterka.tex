\documentclass{xmgr}
\usepackage{ gensymb }
\usepackage{listings}
\usepackage[table]{xcolor}
\lstset{language=C}
\setcounter{secnumdepth}{5}
\usepackage{paralist}
\definecolor{orange}{rgb}{1,0.5,0}

\makeatletter
\newcommand\footnoteref[1]{\protected@xdef\@thefnmark{\ref{#1}}\@footnotemark}
\makeatother

\author   {Daniel Sienkiewicz}
\nralbumu {206358}
\email    {daniel@sienkiewicz.ovh}


\title    {Projekt komputera samochodowego bazujący na systemie mikrokomputera Intel Galileo}
\date     {2016}
\miejsce  {Gdańsk}

\opiekun  {dr inż. Janusz Młodzianowski}

\begin{document}

\begin{abstract}
Celem pracy jest stworzenie systemu komputera pokładowego do samochodu, w którego skład będzie wchodzić: 
\begin{enumerate}
	\item Mikrokomputer Intel Galileo Gen 1, 
	\item Wyświetlacz LCD FTDI EVE VM800B z panelem dotykowym, 
	\item Zestaw czujników symulujących odpowiedni dla rzeczywistego samochodu stan w szczególności:
	\begin{enumerate}
		\item Informacje na temat aktualnej temperatury w samochodzie, na zewnątrz oraz w silniku
		\item Informacje na temat stanu drzwi (otwarte/zamknięte)
		\item Informacje na temat stanu pasów (zapięte/odpięte)
		\item Ekran z obrazem symulujący inteligentne lusterko wsteczne
	\end{enumerate}
	\item Oprogramowanie
\end{enumerate}

\end{abstract}
\keywords{Intel Galileo, 
 $I^2C$,
 SPI, 
 C, 
 Arduino,
 GPIO,
 FTDI EVE,
 VM800,
 Yocto Linux}
\maketitle

%================WPROWADZENIE=====================
\chapter{Wprowadzenie}
\section{Cele}
Celem pracy jest konstrukcja oraz oprogramowanie systemu komputera pokładowego do samochodu. Komputer ma wczytywać temperaturę z czujników panującą w silniku, na zewnątrz, w środku oraz aktualnym stanie zapięcia pasów i zamknięcia drzwi. Jednym z założeń tworzenia systemu jest konstrukcja modułowa umożliwiająca późniejszą rozbudowę funkcjonalności na przykład funkcję rejestrującą pozycję \emph{GPS} wraz z zapisaniem na karcie pamięci \emph{microSD}. Komunikacja użytkownika z komputerem będzie odbywała się poprzez użycie wyświetlacza LCD \emph{FTDI EVE VM800B} z panelem dotykowym.

\section{Założenia}
Do wykonania pracy zostały przyjęte następujące założenia:
\begin{enumerate}
	\item Użycie mikrokomputera \emph{Intel Galileo Gen 1} jako głównego silnika dla całego komputera wraz z zainstalowanym systemem operacyjnym \emph{Linux YOCTO}
	\item Wyświetlacz LCD \emph{FTDI EVE VM800B} z panelem dotykowym jako interfejs komunikacyjny komputera z użytkownikiem, 
	\item Kompilacja przy użyciu systemu Arduino studio oraz natywnego systemu dla Galileo - Linux YOCTO
	\item Symulacja funkcjonalności rzeczywistych czujników samochodu za pomocą dedykowanego symulatora składającego się z zestawu przełączników zapięcia pasów/zamknięcia drzwi oraz potencjometrów służących jako analogowe czujniki temperatury
\end{enumerate}

Parametry takie jak prędkość oraz przebieg nie będą rejestrowane ponieważ są one standardowo dostępne na zegarach samochodowych więc nie ma potrzeby powtarzania tej informacji.

\section{Plan pracy}
TO DO

%================KONIEC WPROWADZENIE=====================

%================Architektura=====================
\chapter{Architektura}
\subsection{Intel Galileo}
Intel Galileo jest  to mikro kontroler oparty na 32-bitowym procesorze Intel® Quark SoC X1000 i taktowaniu 400MHz. Został on wyposażony w standardowy interfejs Arduino składający się z: 14 pinów cyfrowych (w tym 6 pinów mogących pełnić funkcję \emph{PWM}\footnote{ang. Pulse-Width Modulation - technika pozyskiwania wyników analogowych poprzez użycie wyjść cyfrowych}) oraz 6 pinów analogowych. Każdy z tych pinów jest w stanie operować napięciem od 0V do max 5V. Bardzo dużym atutem Galileo jest wbudowana karta sieciowa, port \emph{RS-232}, port \emph{USB} oraz slot karty \emph{microSD}.\cite{GalileoBook}

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.4\textwidth]{images/galileo.png}
    \caption{Galileo Gen 1 Board \label{Galileo Gen 1 Board}}
    \source{\url{http://www.intel.com/content/www/us/en/embedded/products/galileo/galileo-g1-datasheet.html}\cite{GalileoBoard}}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.6\textwidth]{images/IntelGalileoLogicSchematics.jpg}
    \caption{Schemat logiczny układu Intel Galileo\label{IntelGalileoLogicSchematics}}
    \source{\url{https://www.arduino.cc/en/ArduinoCertified/IntelGalileo}\cite{IntelGalileo}}
\end{figure}

Do komunikacji z Galileo programista ma do dyspozycji port RS-232, USB (działające w trybie host oraz client) oraz wyjście Ehernet. Intel Galileo jest zasilane napięciem 5V i 2.0A, które może zostać dostarczone poprzez zasilacz z zestawu lub poprzez podłączenie zasilania do portów PWR\footnote{Port używany jako port zasilania (5V)} oraz GND\footnote{Port używany jako masa - GROUND}. Standardowo środowiskiem programistycznym jest Arduino Studio. Programista pisząc w języku C i używając dostarczonych przez producenta Arduino funkcji do obsługi portów może się z nimi komunikować. Następnie przesyła skompilowaną wersję poprzez kabel USB do urządzenia. Po przesłaniu program zostaje automatycznie załadowany do pamięci urządzenia i uruchomiony. Gdy mamy zainstalowany system operacyjny wtedy komunikację można prowadzić w dowolnym języku programowania łącząc się z systemem poprzez SSH\footnote{ang. secure shell - protokół komunikacyjny służący do połączenia się ze zdalnym komputerem będącym w sieci} lub port RS-232.

\subsection{FDTI EVE VM800B}
Do komunikacji komputera z użytkownikiem został użyty wyświetlacz \emph{LCD FDTI EVE VM800B} wraz z panelem dotykowym oraz wbudowanym kontrolerem audio. 
\begin{figure}[!h]
    \centering
    \includegraphics[height=0.4\textheight]{images/FTDIarchitecture.png}
    \caption{Architektura Ekranu FTDI EVE VM800B}
    \source{FT800 Programmers Guide}
\end{figure}

Podstawowe cechy urządzenia\cite{FTDI}:
\begin{enumerate}
	\item Pojedynczy układ scalony dla wyświetlacza oraz kontrolera Audio
	\item Ekran 3.5" LCD
	\item 262 tys. kolorów
	\item Możliwość wygładzania krawędzi
	\item Możliwość komunikacji poprzez użycie interfejsu $I^2C$ lub SPI
	\item Wbudowany system HMI\footnote{ang. Human - Machine Interface - system bazujący na widgetach}
	\item Zakres pracy wyświetlacza: $-40^{\circ} C$ do $85^{\circ} C$ 
\end{enumerate}

Komunikacja Galileo z Ekranem odbywa się poprzez protokół komunikacyjny \emph{SPI}. Do tego celu została napisana własna wersja funkcji służących do wysłania oraz odczytania danych z ekranu (dokładny opis w rozdziale: "Implementacja").

Rozpoczęcie pracy wyświetlacza polega na wpisaniu określonych wartości do pewnych obszarów jego pamięci określając w ten sposób np. rozdzielczość lub włączenie/wyłącznie modułu odpowiedzialnego za dźwięk czy dotyk. 

Poprzez pamięć urządzenia możemy rozumieć tablicę, w której każda komórka ma swój adres. Wysłanie pewnej wartości do pamięci oznacza więc wpisanie tej wartości do określonej przez adres komórki w tablicy.

Kolejnym krokiem jest wywołanie zestawu funkcji odpowiedzialnych za rysowanie niezbędnych do działania systemu elementów np. guzików. Wszystkie wyświetlane elementy są na początku zapisywane w buforze pamięci. Następnie gdy cały ekran zostanie już przygotowany następuje wyświetlenie wszystkiego co zostało zapisane do bufora po czym zostaje on wyczyszczony.

Procedura rysowania wygląda następująco:
\begin{enumerate}
	\item Poczekaj aż wszystko co miało zostać wyświetlone, zostanie wyświetlone - opróżnij bufor
	\item Określ co będzie rysowane - np. linia lub kropka i dodaj to do bufora
	\item Przesuń się o 4 bity w buforze
	\item Ustaw wszystkie potrzebne parametry - np. wielkość, kolor lub położenie i dodaj to do bufora, pamiętając aby za każdym razem przesunąć się o 4 bity w buforze
	\item Wyświetl wszystko do zostało dodane do bufora 
\end{enumerate}

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.25\textheight]{images/buf.png}
    \caption{Bufor dostępny podczas programowania ekranu VM800}
    \source{FT800 Programmers Guide}
\end{figure}

Należy pamiętać, że wielkość bufora, którą mamy do dyspozycji wynosi 4 Kb. 

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.2\textheight]{images/ekranGalileo.jpg}
    \caption{Schemat połączenia wyświetlacza FTDI EVE z Intel Galileo za pomocą SPI}
    \source{Opracowanie własne}
\end{figure}

\subsection{Symulator samochodu}
Do celów demonstracyjnych oraz implementacjach komputer nie został zamontowany w fizycznym samochodzie. Z tego powodu został zabudowany symulator samochodu mający obrazować pełną pracę pojazdu składający się z:
\begin{enumerate}
	\item 11 przełączników bistabilnych symulujących drzwi samochodu (wraz z bagażnikiem), pasy pasażerów, wrzucenie biegu wstecznego oraz włączenie świateł - wciśniecie przełącznika obrazowane jest poprzez zaświecenie diody półprzewodnikowej
	\item 2 I/O Expandery PCF 8574N 
	\item 3 potencjometrów symulujących czujniki temperatury w samochodzie
\end{enumerate}

Przełączniki wysyłają sygnały cyfrowe, a potencjometry sygnały analogowe. Ze względu na zbyt dużą ilość sygnałów cyfrowych wychodzących z symulatora komunikacja z Galileo odbywać się będzie poprzez \emph{I/O Expander PCF 8574N} wykorzystujący protokół  $I^2C$. Do obsługi tego protokołu również została napisana własna wersja oprogramowania (dokładny opis w rozdziale: "Implementacja").

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.2\textheight]{images/symulatorGalileo.jpg}
    \caption{Schemat połączenia symulatora samochodu z Intel Galileo za pomocą $I^2C$}
    \source{Opracowanie własne}
\end{figure}

%================KONIEC Architektura=====================

%================Mechanizmy komunikacji systemu mikroprocesorowego z otoczeniem=====================
\chapter{Mechanizmy komunikacji systemu mikroprocesorowego z otoczeniem}
\subsection{Odpytywanie w pętli}
Jednym z najprostszych metod pozyskania danych z urządzeń wejścia/wyjścia mikro kontrolera jest odpytywanie urządzeń zewnętrznych w nieskończonej pętli. Jest to najmniej efektywny sposób ponieważ cały czas zajmuje niepotrzebnie zasoby sprzętu niepotrzebnymi zapytaniami. Odczyt stanu urządzeń wejścia/wyjścia może być realizowane mechanizmami systemu operacyjnego lub niskopoziomowo z wykorzystaniem funkcji języka C i/lub Asemblera.

\subsection{Porty}
Porty są jednym z najbardziej podstawowych interfejsów. Najczęściej dzieli się je na porty:
\begin{enumerate}
	\item Cyfrowe
	\item Analogowe
\end{enumerate}

Porty cyfrowe charakteryzują się możliwością przyjęcia lub wysłania sygnału binarnego (1 - jest sygnał, 0 - sygnału nie ma). Najczęściej wysłanie sygnału równego 1 jest równoznaczne z wysłaniem napięcia o wartości 5V oraz odpowiednio wysłanie 0 jest równoznaczne z wysłaniem napięcia równego 0V. Z kolei porty analogowe mogą przesyłać sygnały nawet 10 bitowe. Każdy z portów może działać w jednym  z dwóch trybów: wejścia - oczekiwać na przyjęcie danych od urządzenia zewnętrznego oraz wyjścia - wysyłać dane do urządzenia zewnętrznego.

\subsection{Przerwania}
Przerwanie na poziomie procesora jest to sygnał elektryczny pochodzący bezpośrednio z urządzeń do mikroprocesora.

Są to bezpośrednie funkcje systemu lub sprzętu ułatwiające komunikację ze światem zewnętrznym. Część z nich jest zarezerwowana przez system lecz część jest wolna do wykorzystania przez programistę.

System Galileo bazując na procesorze Quark ma standardowy dla produktów Intela mechanizm obsługi przerwań obsługiwany za pomocą kontrolera przerwań więc do dyspozycji mamy przerwania:
\begin{enumerate}
	\item Programowe
	\item Sprzętowe
	\begin{enumerate}
		\item Niemaskowalne (NMI\footnote{Non-Maskable Interrupt})
		\item Maskowalne
	\end{enumerate}
	\item Wyjątek
\end{enumerate}

W momencie gdy zostaje zgłoszone przerwanie główny wątek programu zostaje zatrzymany po czym wykonywany jest skok do odpowiedniej funkcji.

Przerwania programowe wywołuje się za pomocą komendy \emph{INT XX}, gdzie \emph{XX} oznacza numer przerwania zadeklarowanego w tablicy wektorów przerwań\footnote{ang. interrupt vector table - tablica zawierająca adresy podprogramów służących do obsługi wektorów przerwań}, która jest tworzona przy każdorazowym starcie systemu. Przerwanie to może przyjąć wartości do 255 i są one zarezerwowane przez procesor oraz użytkownika.

Przerwanie sprzętowe jest to rodzaj przerwań wywoływanych przez urządzenia wejścia/wyjścia lub zgłaszane przez procesor. Zostają one wywołane niezależnie w określonych przypadkach. Przerwania te dzielimy na maskowalne oraz niemaskowalne. Główna różnica między nimi polega na możliwości zablokowania przerwań maskowalnych podczas gdy przerwania niemaskowalne muszą zostać obsłużone. Przykładem przerwania niemaskowalnego jest \emph{INT2} czyli popularny \emph{Blue Screen of Death}\footnote{Ekran błędu w systemach Windows pojawiający się po krytycznym błędzie systemu}.

Ostatnim rodzajem przerwań są wyjątki. Wywoływane są podczas napotkania przez procesor błędów oraz niepowodzeń.

Mechanizmem, który bazuje na przerwaniach jest mechanizm Timera. Polega on na wywołaniu funkcji co określony czas (zgłaszane jako przerwanie), którego zarządzaniem zajmuje się urządzenie (lub system operacyjny). Rozwiązanie to jest bardzo podobne do odpytywania w pętli, a następnie wywołania funkcji \emph{delay()} z tą różnicą, że użycie timera jest dokładniejsze ponieważ wykorzystuje zegar czasu rzeczywistego znajdującego się w CPU\footnote{ang. Central Processing Unit - jednostka arytmetyczno-logiczna wykorzystywana do wykonywania obliczeń niezbędnych do działania programu}.

%================KONIEC Mechanizmy komunikacji systemu mikroprocesorowego z otoczeniem=====================

%================Programowanie z użyciem rożnych środowisk=====================
\chapter{Programowanie z użyciem rożnych środowisk}
\section{Programowanie w środowisku Arduino studio}
Programy pisane w środowisku Arduino różnią się nieznacznie od klasycznych programów pisanych w języku C. 

\begin{figure}[!h]
    \centering
    	\includegraphics[height=0.3\textheight]{images/AS.png}
    \caption{Arduino Studio}
    \source{Opracowanie własne}
\end{figure}

Po skompilowaniu i przesłaniu programu z Arduino Studio do Galileo jednorazowo uruchomiona zostaje funkcja \emph{setup()}, która służy do inicjalizacji wszystkich niezbędnych portów. W tej funkcji należy określić początkowe tryby pracy portów. Następnie wywołana zostaje funkcja \emph{loop()}, która jest równoznaczna z funkcją \emph{main()} w języku C, z tą różnicą, że jest wykonywana od momentu startu (zaraz po jednorazowym wykonaniu funkcji \emph{setup()}) aż do wyłączenia systemu. Taką sytuację można utożsamiać z wywołaniem jakiejkolwiek funkcji w bloku \emph{while(1)}.

\begin{lstlisting}[label=bot-dirs-alg,caption=Odpytywanie w nieskończonej pętli w środowisku Arduino]
void loop() {
	funcName();
	delay(1000);
}
\end{lstlisting}

W środowisku \emph{Arduino} aby obsłużyć port analogowy wystarczy ustalić tryb w jakim ma on działać (wejście/wyjście), a następnie wysłać/odczytać dane.  Wpisanie wartości \emph{LOW} jest równoznaczna z wysyłaniem napięcia 0V na określonym pinie, a wpisanie wartości \emph{HIGH} jest równoznaczna z wysyłaniem napięcia 5V na określonym pinie. Arduino dostarcza funkcje do obsługi portów. Podstawowe z nich to:

\begin{enumerate}
	\item \emph{pinMode(PIN, MODE);} - funkcja ustawiająca pin o podanym numerze (PIN) na podany tryb pracy - wejście/wyjście (MODE)
	\item \emph{digitalWrite(PIN, VAL);} - funkcja wpisująca wartość (VAL) - HIGH/LOW - do podanego portu cyfrowego (PIN)
	\item \emph{digitalRead(PIN);} - funkcja czytająca wartość z podanego portu cyfrowego (PIN)
	\item \emph{analogWrite(PIN, VAL);} - funkcja wpisująca wartość (VAL) do podanego portu analogowego (PIN)
	\item \emph{analogRead(PIN);}  - funkcja czytająca wartość z podanego portu analogowego (PIN)
\end{enumerate}

\begin{lstlisting}[label=bot-dirs-alg,caption=Obsługa portu cyfrowego w środowisku Arduino]
int val = 0;
int digitalPin = 1;	
pinMode(digitalgPin, OUTPUT);
val = digitalRead(analogPin);
pinMode(digitalPin, INPUT);
digitalWrite(digitalPin, HIGH);
\end{lstlisting}

\begin{lstlisting}[label=bot-dirs-alg,caption=Obsługa portu analogowego w środowisku Arduino]
int val = 0;
int analogPin = A1;	
pinMode(analogPin, OUTPUT);
val = analogRead(analogPin);
pinMode(analogPin, INPUT);
analogWrite(ledPin, val);
\end{lstlisting}

Arduino oczywiście obsługuje przerwania. Ich obsługa jest bardzo prosta. W środowisku Arduino aby obsłużyć port analogowy wystarczy wywołać funkcję \emph{attachInterrupt}:

\begin{lstlisting}[label=bot-dirs-alg,caption=Obsługa przerwań sprzętowych w środowisku Arduino]
attachInterrupt(pinInt, funcName, mode);
\end{lstlisting}
gdzie \emph{pinInt} jest to pin na którym Arduino będzie nasłuchiwało na przerwanie, \emph{funcName} jest to nazwa funkcji, która zostanie wykonana gdy przerwanie zostanie zgłoszone, \emph{mode} jest to określenie kiedy sygnał może być uznany za przerwanie. Należy pamiętać, że funkcja wywoływana przez przerwanie nie może przyjmować żadnych parametrów oraz zwracać żadnego wyniku. \emph{Mode} może przyjmować wartości: 
\begin{enumerate}
	\item LOW - przerwanie zostanie zgłoszone gdy wartość na określonym pinie jest równa LOW
	\item CHANGE - przerwanie zostanie zgłoszone gdy wartość na określonym pinie zostanie zmieniona
	\item RISING - przerwanie zostanie zgłoszone gdy wartość na określonym pinie zostanie zmieniona z LOW na HIGH
	\item FALLING - przerwanie zostanie zgłoszone gdy wartość na określonym pinie zostanie zmieniona z HIGH na LOW
\end{enumerate}

Obsługa Timera jest analogiczna do obsługi przerwań.
\begin{lstlisting}[label=bot-dirs-alg,caption=Przykładowe użycie timer w środowisku Arduino]
#include <TimerOne.h>
Timer1.initialize(500000);
Timer1.attachInterrupt(funcName, 500000);
\end{lstlisting}

\section{Komunikacja z uradzeniami poprzez mechanizmy systemu operacyjnego}
Z punktu widzenia systemu operacyjnego urządzenia są traktowane tak jak pliki. W systemie YOCTO Linux dostępne są pliki w katalogu /sys/class/gpio/ odpowiadające poszczególnym portom w Galileo. Przy komunikacji należy jednak pamiętać, że nazwy urządzeń nie są intuicyjne tzn. port IO4 nie jest plikiem \emph{/sys/class/gpio/gpio4} (Patrz Dodatek C). Komunikację z portami można obrazować jako wpisanie lub odczytanie danych z pliku. Na początku należy ustalić w jakim trybie ma działać port. W tym celu do pliku \emph{/sys/class/gpio/PORT/direction} trzeba wpisać \emph{out} dla ustawienia jako wyjście lub \emph{in} dla ustawienia jako wejście. Następnie można odczytać lub wpisać dane do wcześniej skonfigurowanego portu. W tym celu do pliku \emph{/sys/class/gpio/PORT/value} należy wpisać wartość \emph{1} dla ustawienia stanu wysokiego - odpowiednik \emph{HIGH} z Arduino lub \emph{0} dla ustawienia stanu niskiego - odpowiednik \emph{LOW} z Arduino, gdzie \emph{PORT} jest to numer odpowiedniego portu według numeracji Galileo. Warto zauważyć, że przesyłane wartości nie są wartościami 8 tylko 1 bitowymi.

Dla języka C wygląda to następująco:
\begin{lstlisting}[label=bot-dirs-alg,caption=Obsługa portu cyfrowego w środowisku Linux (język C)]
FILE *fp;
int value;

// Ustawienie portu cyfrowego nr 13 jako port wyjscia
fp = fopen("/sys/class/gpio/gpio39/direction", "w");
fprintf(fp, "out");
fclose(fp);

// Wpisanie wartosci do portu cyfrowego
fp = fopen("/sys/class/gpio/gpio39/value", "w");
fprintf(fp, "1");
fclose(fp);

// Odczytanie wartosci z portu cyfrowego
fp = fopen("/sys/class/gpio/gpio39/value", "r");
fscanf(fp, "%i", &value);
fclose(fp);
\end{lstlisting}

oraz podobnie dla języków skryptowych np. Bash:

\begin{lstlisting}[label=bot-dirs-alg,caption=Obsługa portu cyfrowego w środowisku Linux (bash)]
# Ustawienie portu cyfrowego nr 13 jako port wyjścia
root@henio:~# echo -n "out" > /sys/class/gpio/gpio39/direction

# Wpisanie wartosci do portu cyfrowego
root@henio:~#  echo -n "0" > /sys/class/gpio/gpio39/value
root@henio:~#  echo -n "1" > /sys/class/gpio/gpio39/value

# Odczytanie wartosci z portu cyfrowego
root@henio:~# echo -n "in" > /sys/class/gpio/gpio28/direction
root@henio:~# cat /sys/class/gpio/gpio28/value
\end{lstlisting}

%================KONIEC Programowanie z użyciem rożnych środowisk=====================

%================IMPLEMENTACJA=====================
\chapter{Implementacja}
\section{Protokół komunikacyjny $I^2C$}
\emph{$I^2C$}\footnote{ang. Inter-Integrated Circuit} jest szeregowym interfejsem stworzonym przez firmę \emph{Philips} służącym do przesyłania danych między urządzeniami elektrycznymi. 

Podstawową cechą \emph{$I^2C$} jest wykorzystywanie dwóch linii służących do komunikacji: dwukierunkowa linia danych \emph{SDA\footnote{ang. Serial Data Line}} oraz jednokierunkowa linia zegarowa \emph{SCL\footnote{ang. Serial Clock Time}}. Protokół I2C bazuje na przesyłaniu ramek (pakietów) składających się z sekwencji: START -> dane -> STOP. 

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.3\textheight]{images/i2c.png}
    \caption{Przebieg czasowy protokołu $I^2C$}
    \source{\url{http://www.byteparadigm.com/applications/introduction-to-i2c-and-spi-protocols/}\cite{byteparadigm}}
\end{figure}

Do wygenerowania impulsu START oraz STOP wystarczy ustawić linię \emph{SDA} oraz \emph{SCL} w stan HIGH (5V) po czym należy chwilkę odczekać. Dane wysyłane/odbierane są bit po bicie - na początku należy ustawić linię \emph{SCL} w stan wysoki (HIGH), odczytać wartość na porcie \emph{SDA}, a następnie zmienić stan linii \emph{SCL} na niski (LOW).

Dane wysyłane są od najstarszego do najmłodszego bitu. Każda paczka potwierdzona jest przez odbiornik (bit ACK\footnote{ang. Acknowledge}). Należy również pamiętać, aby każdą komunikację z urządzeniem rozpocząć i zakończyć ustawiając linie \emph{SDA} oraz \emph{SCL} w stan nieaktywny (HIGH) - wygenerowanie sekwencji STOP.

 Podstawowymi zaletami protokołu są:
\begin{enumerate}
	\item Połączenia składają się tylko z dwóch linii co znacznie ogranicza liczbę kabli wychodzących z urządzenia
	\item Duża dostępność sprzętu w sklepach
	\item Transmisja jest odporna na zakłócenia zewnętrzne
	\item Bez większych problemów można dodawać oraz odejmować układy korzystające z magistrali
\end{enumerate}

Nazwa $I^2C$ jest nazwą zastrzeżoną dlatego też w literaturze bardzo często spotyka się określenie \emph{TWI}\footnote{ang. Two Wire Interface}. Jest ono stosowane w mikro kontrolerach firmy \emph{Atmel}. 

\subsection{I/O Expander PCF8574N}
W symulatorze ze względu na dużą ilość wychodzących sygnałów zastosowano komunikacje poprzez $I^2C$. Do obsługi tego został zamontowane dwa I/O Expandery PCF 8574N zbierające wszystkie sygnały cyfrowe wychodzące z symulatora do Galileo. Dzięki temu zamiast używać dwunastu linii cyfrowych, wykorzystywane są jedynie dwie niezbędne do komunikacji poprzez $I^2C$ co znacznie ułatwiło dalsze korzystanie z Galileo ze względu na pozostałe wolne porty cyfrowe, które będą potrzebne w dalszej części do komunikacji z wyświetlaczem. Zaletą tego rozwiązania jest możliwość późniejszego podłączenia większej ilości czujników bez jakiejkolwiek ingerencji w okablowanie Galileo.

Do rozpoczęcia komunikacji należy wygenerować bit START oraz zaadresować urządzenie, z którym będziemy się komunikować.

Adresowanie urządzenia odbywa się poprzez wysłanie pojedynczych bitów adresu (pamiętając o kolejności MSB->LCB\footnote{Wysyłanie odbywa się w kolejności od najbardziej znaczących (najstarszych) bitów}) oraz wygenerowanie impulsu zegara. Gdy chcemy zaadresować urządzenie, którego adresem jest np. 4 należy wykonać:
\begin{lstlisting}[label=bot-dirs-alg,caption=Adresowanie urządzenia $I^2C$ na przykładzie PCF8574N]
int adres = 4;
for(m = 0x80; m; m >>= 1){
    if(adres & m)         
      digitalWrite(sda, HIGH);
    else
      digitalWrite(sda, LOW);
        
   digitalWrite(scl, HIGH);
   digitalWrite(scl, LOW); 
}
\end{lstlisting}

Kolejnym krokiem jest ustalenie czy będziemy chcieli z urządzenia przeczytać dane czy je wysłać. W tym celu należy wysłać 1 lub 0  jako kolejny bit. Po otrzymaniu potwierdzenia na linii \emph{SDA} można zacząć czytać dane przesyłane z urządzenia. Na zakończenia transmisji należy wysłać sygnał \emph{STOP}.

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.25\textheight]{images/read_i2c.png}
    \caption{Przykładowy schemat odbierania danych poprzez $I^2C$ na przykładzie PCF8574N\label{$I^2C$}}
    \source{Karta katalogowa I/O Expander PCF8574N}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.2\textheight]{images/write_i2c.png}
    \caption{Przykładowy schemat wysyłania danych poprzez $I^2C$ na przykładzie PCF8574N\label{$I^2C$}}
    \source{Karta katalogowa I/O Expander PCF8574N}
\end{figure}

Galileo posiada dostarczoną od Arduino bibliotekę do obsługi $I^2C$ jednak podczas próby użycia jej w projekcie wystąpiły problemy z kompatybilnością z używanym sprzętem w związku z tym na potrzeby projektu napisana została własna wersja biblioteki obsługującej komunikację poprzez protokół $I^2C$.

\section{Protokół komunikacyjny SPI}
Wyświetlacz LCD wyposażony jest w protokół SPI\footnote{ang. Serial Peripherial Interface}. Składa się on z czterech podstawowych linii - dwóch służących do przesyłania danych w przeciwnych kierunkach, jednej z sygnałem taktującym, synchronizującym transfer danych oraz linii \emph{Chip Select}. 

Linia MISO\footnote{ang. Master In Slave Out} jest linią wejścia danych dla urządzenia nadrzędnego (master), a wyjściem dla urządzenia podrzędnego (slave), linia MOSI\footnote{ang. Master Out Slave In} jest wyjściem dla urządzenia master, a wejściem dla slave. Linia SCK\footnote{ang. Serial Clock} jest wejściem taktującym zegar. Sygnał taktujący jest zawsze generowany przez układ master. Transmisja danych na obydwu liniach jest zawsze dwukierunkowa i odbywa się jednocześnie - nadanie danych na linii MISO wiąże się z nadaniem danych na linii MOSI. Nie zawsze jednak nadane dane niosą ze sobą informację - najczęściej nadawane informacje płyną w jedną stronę podczas, gdy w tym samym czasie wysyłane zostają puste dane.\cite{Dorra}

\begin{figure}[!h]
    \centering
    \includegraphics[height=0.25\textheight]{images/spi.png}
    \caption{Przebiegi czasowe interfejsu SPI dla sygnału zegarowego o CPHA=0}
    \source{\url{http://castor.am.gdynia.pl/~dorra}\cite{Dorra}}
\end{figure}

\subsection{Komunikacja poprzez protokół SPI}
Komunikacja zawsze przebiega dwustronnie (duplex\footnote{Nadawanie i odbieranie informacji odbywa się w obu kierunkach}). Zmienia taktu zegara z niskiego na wysoki daje możliwość odczytania danych z linii MISO i jednocześnie wysłania danych na linię MOSI. W przypadku zmiany taktu zegara z wysokiego na niski dane zostają wysłane poprzez linię MISO i jednocześnie odczytane z linii MOSI. W porównaniu z $I^2C$ protokół SPI jest dużo szybszy. Maksymalna prędkość protokółu $I^2C$ w wydaniu z 2012r. to 5-MHz.

Podobnie jak w przypadku protokołu $I^2C$ została napisana własna wersja biblioteki do obsługi protokołu SPI. Do komunikacji niezbędne było napisanie funkcji:
\begin{enumerate}
	\item \emph{void sendData(int data)} - funkcja wysyłająca wartość 8 bitową
	\item \emph{void ft800memWriteX(unsigned long ftAddress, unsigned char ftDataX)} - funkcja wpisująca podaną wartość X - bitową na podany adres, gdzie X może być wartością 8, 16 lub 32 bitową
	\item \emph{unsigned char ft800memReadX(unsigned long ftAddress)} - funkcja odczytująca wartość X - bitową z podanego adresu, gdzie X może być wartością 8, 16 lub 32 bitową
	\item \emph{unsigned int incCMDOffset(unsigned int currentOffset, unsigned char commandSize)} - funkcja zwiększająca offset w buforze pamięci ekranu
	\item \emph{void ft800cmdWrite(unsigned char ftCommand)} - funkcja wysyłająca podaną komendę do ekranu - np. Start urządzenia ($FT800_ACTIVE$)
\end{enumerate}

Wyświetlacz ma możliwość korzystania z systemu \emph{HMI} więc do obsługi zostały napisane proste API, które dostarcza następujące funkcjonalności:
 \begin{enumerate}
	\item inicjalizacja ekranu
	\item rysowanie kółka o podanym rozmiarze w podanym miejscu
	\item rysowanie linii po podanych końcach
	\item wypisanie tekstu
	\item wypisanie cyfr
	\item narysowanie guzika po podanym miejscu i podanym rozmiarze
\end{enumerate}

Przykładowe wyświetlenie linii o pozycji, kolorze oraz pozycji podanej w parametrach:
\begin{lstlisting}[label=bot-dirs-alg,caption=Narysowanie linii na ekranie]
void linia(unsigned long color, unsigned long x1, unsigned long y1, 
unsigned long x2, unsigned long y2, unsigned long width){
 ft800memWrite32(RAM_CMD+cmdOffset, (DL_BEGIN|LINES));
 cmdOffset=incCMDOffset(cmdOffset, 4);
 
 ft800memWrite32(RAM_CMD+cmdOffset, (DL_COLOR_RGB|color));
 cmdOffset=incCMDOffset(cmdOffset,4);

 ft800memWrite32(RAM_CMD+cmdOffset, (DL_LINE_WIDTH|width));
 cmdOffset=incCMDOffset(cmdOffset,4);

 ft800memWrite32(RAM_CMD+cmdOffset, (DL_VERTEX2F|(x1<<15)|y1));
 cmdOffset=incCMDOffset(cmdOffset,4);
  
 ft800memWrite32(RAM_CMD+cmdOffset, (DL_VERTEX2F|(x2<<15)|y2));
 cmdOffset=incCMDOffset(cmdOffset,4);	
}
\end{lstlisting}

Podobnie gdy chcemy wyświetlić na ekranie kropkę:
\begin{lstlisting}[label=bot-dirs-alg,caption=Narysowanie kropki na ekranie]
void kropka(unsigned long color, unsigned int size, unsigned long x, 
unsigned long y){ 
 ft800memWrite32(RAM_CMD+cmdOffset, (DL_POINT_SIZE|size));
 cmdOffset=incCMDOffset(cmdOffset,4);

 ft800memWrite32(RAM_CMD+cmdOffset, (DL_BEGIN|FTPOINTS));
 cmdOffset=incCMDOffset(cmdOffset, 4);

 ft800memWrite32(RAM_CMD+cmdOffset, (DL_COLOR_RGB|color));
 cmdOffset=incCMDOffset(cmdOffset,4);
 
 ft800memWrite32(RAM_CMD+cmdOffset, (DL_VERTEX2F|(x<<15)|y));
 cmdOffset=incCMDOffset(cmdOffset,4);
}
\end{lstlisting}

%================KONIEC IMPLEMENTACJA=====================

%================Działanie komputera pokładowego=====================
\chapter{Działanie komputera pokładowego}
\section{Założenia funkcjonalne projektu}
Najważniejszym założeniem funkcjonalnym była komunikacja z zestawem czujników, które mogą być zamontowane w samochodzie. 

W projekcie zostały użyte czujniki otwarcia/zamknięcia drzwi, zapięcia pasów, włączenia/wyłączenia świateł oraz czujniki temperatury. Dodatkowym elementem była komunikacja z zewnętrznym wyświetlaczem LCD służącym do komunikacji pomiędzy użytkownikiem a komputerem. Samochód obrazowany został za pomocą zbudowanego symulatora.

\section{Opis działania}
Proponowany komputer pokładowy jest całkowicie osobnym systemem niezależnym od sprzętu aktualnie posiadanego w samochodzie. Użytkownik montuje zestaw czujników oraz łączy je z komputerem i ekranem. Po wejściu do samochodu oraz włączeniu zapłonu powoduje automatyczny start systemu. 

Na ekranie pojawia się powitanie oraz ekran startowy, na którym można zobaczyć symulację aktualnej pozycji GPS, temperaturę panującą w środku samochodu, na zewnątrz oraz w silniku. Stan drzwi i pasów z wizualizowany został poprzez miniaturkę samochodu z aktywnie otwierającymi się drzwiami, zapalającymi światłami oraz ikonką obrazującą stan zapiętych pasów. 

Na ekranie widnieją 2 przyciski - \emph{Save data} oraz \emph{Smart Mirror}. Pierwszy z nich daje możliwość zapisu aktualnej pozycji GPS oraz temperatur na karcie pamięci microSD, drugi przechodzi w tryb aktywnego lusterka wstecznego, który może również służyć jako czujnik cofania co bardzo przydaje się podczas parkowania w ciasnych miejskich parkingach. Wyłączenie systemu następuje wraz z wyłączeniem zapłonu w samochodzie. Zapis do pliku odbywa się poprzez użycie standardowych funkcji systemu operacyjnego. 

Na początku przygotowana zostaje komenda a natępnie poprzez wywołanie funkcji \emph{system()} zostaje ona wykonana. Do tego celu można również użyć standardowego mechanizmu dostępnego w Arduino. Za pomocą funkcji \emph{SD.open(filename)}  należy otworzyć plik na karcie pamięci po czym zapis polega na wpisaniu danych za pomocą funkcji \emph{println()}. 

W tym przypadku należy pamiętać o zaimportowaniu pliku nagłówkowego \emph{SD.h}.

\begin{figure}[!h]
    \centering
    	\includegraphics[height=0.55\textheight]{images/zestaw.jpg}
    \caption{Zdjęcie gotowego zestawu}
    \source{Opracowanie własne}
\end{figure}

\begin{figure}[!hp]
    \centering
    	\includegraphics[height=0.9\textheight]{images/symulator.png}
    \caption{Schemat elektryczny symulatora samochodu}
    \source{Opracowanie własne}
\end{figure}

\begin{figure}[!hp]
    \centering
    	\includegraphics[height=0.7\textheight]{images/codeDiagram.png}
    \caption{Schemat blokowy programu}
    \source{Opracowanie własne}
\end{figure}

\begin{lstlisting}[label=bot-dirs-alg,caption=Obsługa karty microSD za pomocą mechanizmu Arduino]
void writeSD(char *filename, char * data){
  File dataFile = SD.open(filename, FILE_WRITE);
  dataFile.println(data);
  dataFile.close();
}
  
void readSD(char *filename){
  File dataFile = SD.open(filename);
  while (dataFile.available()) {
      Serial.write(dataFile.read());
  }
  dataFile.close();
}
\end{lstlisting}

\begin{lstlisting}[label=bot-dirs-alg,caption=Obsługa karty microSD za pomocą mechanizmu systemu operacyjnego]
  String command = "";  
  command = "echo testTekst";
  command += " >> /tmp/daniel.txt";
  system(command.buffer);
\end{lstlisting}

Komunikacja z Intel Galileo z ekranem odbywa się używając protokołu SPI. Łącznie użytych zostało 7 linii: SDI, SDO, clock, PD, CS\footnote{Linia Chip select wyświetlacza} oraz PWR\footnote{ang. Power - 5V} i GND\footnote{ang. Ground}. 

Komunikacja komputera z symulatorem odbywa się poprzez użycie $I^2C$. Odczytanie wartości czujników cyfrowych odbywa się po otrzymaniu przerwania sprzętowego wychodzącego z I/O Expander przy zmianie jakiejkolwiek wartości np. przy otworzeniu drzwi. 

Odczyt czujników analogowych (temperatura) odbywa się przy użyciu timera co określony w programie czas. 

Gdy została wybrana opcja zapisu danych na kartę pamięci wtedy w nieskończonej pętli aktualna pozycja GPS zostaje zapisywana do pliku tekstowego do momentu wyłączenia systemu, wyczerpania miejsca na karcie lub zmiany tej opcji przez użytkownika.

\section{Wnioski oraz własne doświadczenia}
Komputer został tak zaprojektowany tak aby w łatwy sposób można było dodać kolejne funkcjonalności zależne od potrzeb użytkownika. Jako propozycje można uwzględnić:
\begin{enumerate}
	\item Lokalizator GPS - wczytywanie aktualnej pozycji GPS i wyświetlanie jej na wyświetlaczu
	\item Kamerka cofania - wyświetlanie obrazu z kamerki cofania na wyświetlaczu
	\item Czujnik deszczu - automatyczne włączenie wycieraczek i dopasowanie ich prędkości w zależności od obfitości opadów i prędkości samochodu, dodatkowe włączenie wycieraczki tylnej w momencie gdy zostanie wrzucony bieg wsteczny
	\item Sterowanie głośnością radia w zależności od prędkości samochodu
	\item Blokada immobilizer
	\item Obsługa telefonu komórkowego za pomocą bluetooth
	\item Router - dodanie modułu karty WiFi w połączeniu z odbieraniem sieci komórkowej GPRS oraz rozsyłanie jej w samochodzie
\end{enumerate}
Jednak na potrzeby tej wersji projektu nie zostały one zaimplementowane. Oczywiście ogranicza nas tylko nasza wyobraźnia oraz finanse jakie chcemy przeznaczyć na rozbudowę systemu o dodatkowe moduły. 

%================KONIEC Działanie komputera pokładowego=====================

%================Zakończenie=====================
\summary
TO DO

%================KONIEC Zakonczenie=====================

%================Dodatki=====================
\appendix
\chapter{Karty Katalogowe}
Katalog \emph{datasheets} zawiera karty katalogowe użytych podzespołów
\begin{enumerate} 
\item Intel Galileo.pdf - Karta katalogowa Intel Galileo
\item PCF8574.pdf - Karta katalogowa I/O Expander PCF 8574N
\item VM800B.pdf - Karta katalogowa ekranu FTDI EVE VM800B
\end{enumerate}
\chapter{Porównanie dostępnych na rynku mikro kontrolerów}
\begin{table}[!tbh]
\begin{tabular}{|c|c|c|c|} \hline
 & \textbf{Intel Galileo} & \textbf{Raspberry Pi (Model B)} & \textbf{Arduino Uno} \\ \hline
Wymiary & 10cm x 7cm & 85.60mm x 56mm x 21mm & 5.59cm x 16.5cm \\ \hline
Procesor & Intel Quark X1000 & Broadcom BCM2835 & ATmega328 \\ \hline
Taktowanie & 400MHz	& 700MHziv & 16 MHz\\ \hline
Cache & 16 KB & 32KB L1 cache, 128KB L2 cache & - \\ \hline
RAM & 512 SRAM & 512 SRAM & 2 kB \\ \hline
Analog I/O	& 6 & 17 & 6 \\ \hline
Digital I/O	& 14 & 8 & 14 \\ \hline
PWM	& 6 & 1 & 6 \\ \hline
\end{tabular}
\caption{Specyfikacja dostępnych na rynku mikro kontrolerów}
\source{\url{http://eu.mouser.com/applications/open-source-hardware-galileo-pi/}\cite{GalileoVSRaspberry}}
\source{\url{http://botland.com.pl/arduino-moduly-glowne/1060-arduino-uno-r3.html}\cite{Botland}}
\end{table}

\chapter{Mapowanie portów Intel Galileo na pliki w systemie Linux}
\begin{table}[!hp]
\begin{tabular}{|c|c|c|} \hline
\textbf{Quark X1000} & \textbf{Sysfs GPIO} & \textbf{Galileo/Arduino port} \\ \hline
GPORT4 BIT7 & gpio51 & IO1 \\ \hline
GPIO6 & gpio14 & IO2 \\ \hline
GPIO7 & gpio15 & IO3 \\ \hline
GPORT1 BIT4 & gpio28 & IO4 \\ \hline
GPORT0 BIT1 & gpio17 & IO5 \\ \hline
GPORT1 BIT0 & gpio24 & IO6 \\ \hline
GPORT1 BIT3 & gpio27 & IO7 \\ \hline
GPORT1 BIT2 & gpio26 & IO8 \\ \hline
GPORT0 BIT3 & gpio19 & IO9 \\ \hline
GPORT0 BIT0 & gpio16 & IO10 \\ \hline
GPORT1 BIT1 & gpio25 & IO11 \\ \hline
GPORT3 BIT2 & gpio38 & IO12 \\ \hline
GPORT3 BIT3 & gpio39 & IO13 \\ \hline
GPORT4 BIT0 & gpio44 & A0 \\ \hline
GPORT4 BIT1 & gpio45 & A1 \\ \hline
GPORT4 BIT2 & gpio46 & A2 \\ \hline
GPORT4 BIT3 & gpio47 & A3 \\ \hline
GPORT4 BIT4 & gpio48 & A4 \\ \hline
GPORT4 BIT5 & gpio49 & A5 \\ \hline
\end{tabular}
\caption{Mapowanie portów Intel Galileo na pliki w systemie Linux}
\source{\url{http://www.malinov.com/Home/sergey-s-blog}\cite{SergeySBlog}}
\end{table}

\chapter{Programy}
Katalogi \emph{Source} zawiera kod źródłowy oprogramowania stworzonego na potrzeby pracy. 
\begin{enumerate} 
	\item VM800Galileo.ino - główny kod programu
	\item FT800.* - obsługa wyświetlacza LCD przy użyciu protokołu komunikacyjnego SPI
	\item FT800api.* - API udostępniające podstawowe funkcje systemy HMI dostępne dla wyświetlacza LCD
	\item I2C.* - obsługa I/O Expander przy użyciu protokołu komunikacyjnego $I^2C$
	\item simulator.* - komunikacja z symulatorem samochodu
\end{enumerate}

%================KONIEC Dodatki=====================

\bibliographystyle{unsrt}
\bibliography{magisterka}

\listoftables

\listoffigures

\oswiadczenie

\end{document}